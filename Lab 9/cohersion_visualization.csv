Java Code,LCOM 1,LCOM 2,LCOM 3,LCOM 4,LCOM 5,YALCOM
"public class ToolsActions {
public static final class Preferences implements Listener { private final PreferencesDialog preferencesDialog; private final ResultTable resultTable; private final StatusBar statusBar; public Preferences(PreferencesDialog preferencesDialog, ResultTable resultTable, StatusBar statusBar) { this.preferencesDialog = preferencesDialog; this.resultTable = resultTable; this.statusBar = statusBar; }
public void handleEvent(Event event) { // show the preferences dialog preferencesDialog.open(); // refresh the results and status bar in case anything was changed resultTable.updateResults(); resultTable.updateColumnNames(); statusBar.updateConfigText(); } }
",200,124,11,11,0.938,0.291
"Public class HelpMenuActions {   public static final class GettingStarted implements Listener {   public GettingStarted() {}    public void handleEvent(Event event) {    new GettingStartedDialog().open();   }  }   public static final class CommandLineUsage implements Listener {   private CommandLineProcessor cli;    public CommandLineUsage(CommandLineProcessor cli) {    this.cli = cli;   }    public void handleEvent(Event event) {    InfoDialog dialog = new InfoDialog(Version.NAME, Labels.getLabel(""title.commandline""));    dialog.setMessage(cli.toString());    dialog.open();   }  }   public static final class About implements Listener {   private AboutDialog aboutDialog;    public About(AboutDialog aboutDialog) {    this.aboutDialog = aboutDialog;   }    public void handleEvent(Event event) {     aboutDialog.open();    }  }   public static final class Website implements Listener {   public Website() {}    public void handleEvent(Event event) {    BrowserLauncher.openURL(Version.WEBSITE);   }  }   public static final class FAQ implements Listener {   public FAQ() {}    public void handleEvent(Event event) {    BrowserLauncher.openURL(Version.FAQ_URL);   }  }   public static final class Issues implements Listener {   public Issues() {}    public void handleEvent(Event event) {    BrowserLauncher.openURL(Version.ISSUES_URL);   }  }",148,143,14,14,0.92,0.77
"public class InetAddressUtils { static final Logger LOG = LoggerFactory.getLogger();
// Warning! IPv4 specific code public static final Pattern HOSTNAME_REGEX = Pattern.compile(""\\b((([a-z]|[a-z0-9][a-z0-9\\-]*[a-z0-9])\\.)+([a-z]{2,})|\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\\b"", CASE_INSENSITIVE);
public static InetAddress startRangeByNetmask(InetAddress address, InetAddress netmask) { byte[] addressBytes = address.getAddress(); byte[] netmaskBytes = netmask.getAddress(); for (int i = 0; i < addressBytes.length; i++) { addressBytes[i] = i < netmaskBytes.length ? (byte) (addressBytes[i] & netmaskBytes[i]) : 0; } try { return InetAddress.getByAddress(addressBytes); } catch (UnknownHostException e) { // this should never happen as we are modifying the same bytes received from the InetAddress throw new IllegalArgumentException(e); } }
public static InetAddress endRangeByNetmask(InetAddress address, InetAddress netmask) { byte[] netmaskBytes = netmask.getAddress(); byte[] addressBytes = address.getAddress(); for (int i = 0; i < addressBytes.length; i++) { addressBytes[i] = (byte) (i < netmaskBytes.length ? (addressBytes[i] | ~(netmaskBytes[i])) : 255); } try { return InetAddress.getByAddress(addressBytes); } catch (UnknownHostException e) { // this should never happen as we are modifying the same bytes received from the InetAddress throw new IllegalArgumentException(e); } }
/** * Compares two IP addresses. * @return true in case inetAddress1 is greater than inetAddress2 */ public static boolean greaterThan(InetAddress inetAddress1, InetAddress inetAddress2) { byte[] address1 = inetAddress1.getAddress(); byte[] address2 = inetAddress2.getAddress(); for (int i = 0; i < address1.length; i++) { if ((address1[i] & 0xFF) > (address2[i] & 0xFF)) return true; else if ((address1[i] & 0xFF) < (address2[i] & 0xFF)) break; } return false; }
public static InetAddress increment(InetAddress address) { return modifyInetAddress(address, true); }
public static InetAddress decrement(InetAddress address) { return modifyInetAddress(address, false); }
/** * Increments or decrements an IP address by 1. * @return incremented/decremented IP address */ private static InetAddress modifyInetAddress(InetAddress address, boolean isIncrement) { try { byte[] newAddress = address.getAddress(); for (int i = newAddress.length-1; i >= 0; i--) { if (isIncrement) { if (++newAddress[i] != 0x00) { break; } } else { if (--newAddress[i] != 0x00) { break; } }
} return InetAddress.getByAddress(newAddress); } catch (UnknownHostException e) { // this exception is unexpected here assert false : e; return null; } }
/** * Parses the netmask string provided in special text format: * A.B.C.D, where each term is 0-255 or empty. If any term is empty, it is the same as 255. * Another supported format is CIDR (""/24""). * <p/> * Only IPv4 is supported. */ public static InetAddress parseNetmask(String netmaskString) throws UnknownHostException { if (netmaskString.startsWith(""/"")) { // CIDR netmask, e.g. ""/24"" - number of bits set from the left int totalBits = Integer.parseInt(netmaskString.substring(1)); return parseNetmask(totalBits); }
// IP-like netmask (IPv4) netmaskString = netmaskString.replaceAll(""\\.\\."", "".255.""); netmaskString = netmaskString.replaceAll(""\\.\\."", "".255.""); return InetAddress.getByName(netmaskString); }
public static InetAddress parseNetmask(int prefixBits) { byte[] mask = new byte[prefixBits > 32 ? 16 : 4]; for (int i = 0; i < mask.length; i++) { int curByteBits = Math.min(prefixBits, 8); prefixBits -= curByteBits; mask[i] = (byte)((((1 << curByteBits)-1)<<(8-curByteBits)) & 0xFF); } try { return InetAddress.getByAddress(mask); } catch (UnknownHostException e) { throw new RuntimeException(e); } }
/** * Where mask bits are set, we use prototype bits. * Where mask bits are cleared, we leave bits as is. * @param addressBytes this array is modified according to the maskBytes and prototypeBytes */ public static void maskPrototypeAddressBytes(byte[] addressBytes, byte[] maskBytes, byte[] prototypeBytes) { for (int i = 0; i < addressBytes.length; i++) { addressBytes[i] = (byte) ((addressBytes[i] & ~maskBytes[i]) | (prototypeBytes[i] & maskBytes[i])); } }
/** * Checks whether the passed address is likely either a broadcast or network address */ public static boolean isLikelyBroadcast(InetAddress address, InterfaceAddress ifAddr) { byte[] bytes = address.getAddress(); int last = bytes.length - 1; if (ifAddr != null) { return address.equals(ifAddr.getBroadcast()) || // TODO: 0 is actually not correct for smaller networks than /24 bytes[last] == 0 && Arrays.equals(bytes, 0, last, ifAddr.getAddress().getAddress(), 0, last); } return bytes[last] == 0 || bytes[last] == (byte)0xFF; }
public static InterfaceAddress getLocalInterface() { InterfaceAddress anyAddress = null; try { List<NetworkInterface> interfaces = getNetworkInterfaces().stream() .filter(i -> i.getParent() == null && !i.isVirtual()).collect(toList());
for (NetworkInterface networkInterface : interfaces) { try { if (networkInterface.getHardwareAddress() == null) continue; } catch (SocketException ignore) {}
for (InterfaceAddress ifAddr : networkInterface.getInterfaceAddresses()) { anyAddress = ifAddr; InetAddress addr = ifAddr.getAddress(); if (!addr.isLoopbackAddress() && addr instanceof Inet4Address) return ifAddr; } } } catch (SocketException e) { LOG.log(Level.FINE, ""Cannot enumerate network interfaces"", e); } return anyAddress; }
public static NetworkInterface getInterface(InterfaceAddress address) { try { if (address == null) return null; return NetworkInterface.getByInetAddress(address.getAddress()); } catch (SocketException e) { return null; } }
public static NetworkInterface getInterface(InetAddress address, Stream<NetworkInterface> interfaceStream) { try { if (address == null) return null; return interfaceStream.filter(i -> i.getInterfaceAddresses().stream().anyMatch(ifAddr -> { InetAddress netmask = parseNetmask(ifAddr.getNetworkPrefixLength()); return startRangeByNetmask(address, netmask).equals(startRangeByNetmask(ifAddr.getAddress(), netmask)); })).findFirst().orElse(null); } catch (Exception e) { return null; } }
public static NetworkInterface getInterface(InetAddress address) { try { return getInterface(address, NetworkInterface.networkInterfaces()); } catch (Exception e) { return null; } }
public static InterfaceAddress matchingAddress(NetworkInterface netIf, Class<? extends InetAddress> addressClass) { if (netIf == null) return null; return netIf.getInterfaceAddresses().stream().filter(i -> i.getAddress().getClass() == addressClass).findFirst().orElse(null); }
public static List<NetworkInterface> getNetworkInterfaces() throws SocketException { List<NetworkInterface> interfaces = list(NetworkInterface.getNetworkInterfaces()); if (!Platform.WINDOWS) reverse(interfaces); return interfaces; }}
",120,0,16,12,1.033,0.75
"public interface WinIpHlpDll extends Library { WinIpHlpDll dll = Loader.load(); class Loader { public static WinIpHlpDll load() { try { return Native.loadLibrary(""iphlpapi"", WinIpHlpDll.class); } catch (UnsatisfiedLinkError e) { return Native.loadLibrary(""icmp"", WinIpHlpDll.class); } } }
class AutoOrderedStructure extends Structure { // this is a requirement of newer JNA, possibly it won't work on some JVM, but probability is quite small @Override protected List<String> getFieldOrder() { ArrayList<String> fields = new ArrayList<>(); for (Field field : getClass().getFields()) { if (!isStatic(field.getModifiers())) fields.add(field.getName()); } return fields; } }
/** * Wrapper for Microsoft's <a href=""http://msdn.microsoft.com/en-US/library/aa366045.aspx"">IcmpCreateFile</a> */ Pointer IcmpCreateFile();
/** * Wrapper for Microsoft's <a href=""https://docs.microsoft.com/en-us/windows/desktop/api/icmpapi/nf-icmpapi-icmp6createfile"">Icmp6CreateFile</a> */ Pointer Icmp6CreateFile();
/** * Wrapper for Microsoft's <a href=""http://msdn.microsoft.com/en-us/library/aa366043.aspx"">IcmpCloseHandle</a> */ boolean IcmpCloseHandle(Pointer hIcmp);
/** * Wrapper for Microsoft's <a href=""http://msdn.microsoft.com/EN-US/library/aa366050.aspx"">IcmpSendEcho</a> */ int IcmpSendEcho( Pointer hIcmp, IpAddrByVal destinationAddress, Pointer requestData, short requestSize, IpOptionInformationByRef requestOptions, Pointer replyBuffer, int replySize, int timeout );
/** * Wrapper for Microsoft's <a href=""https://docs.microsoft.com/en-us/windows/desktop/api/icmpapi/nf-icmpapi-icmp6sendecho2"">Icmp6SendEcho2</a> */ int Icmp6SendEcho2( Pointer hIcmp, Pointer event, Pointer apcRoutine, Pointer apcContext, Ip6SockAddrByRef sourceAddress, Ip6SockAddrByRef destinationAddress, Pointer requestData, short requestSize, IpOptionInformationByRef requestOptions, Pointer replyBuffer, int replySize, int timeout );
/** * Wrapper for Microsoft's <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa366358(v=vs.85).aspx"">SendARP</a> */ int SendARP( IpAddrByVal destIP, int srcIP, Pointer pMacAddr, Pointer pPhyAddrLen );
class IpAddr extends AutoOrderedStructure { public byte[] bytes = new byte[4]; }
class IpAddrByVal extends IpAddr implements Structure.ByValue { }
class Ip6SockAddr extends AutoOrderedStructure { public short family = 10; public short port; public int flowInfo; public byte[] bytes = new byte[16]; public int scopeId; }
class Ip6SockAddrByRef extends Ip6SockAddr implements Structure.ByReference { }
class IpOptionInformation extends AutoOrderedStructure { public byte ttl; public byte tos; public byte flags; public byte optionsSize; public Pointer optionsData; }
class IpOptionInformationByVal extends IpOptionInformation implements Structure.ByValue { }
class IpOptionInformationByRef extends IpOptionInformation implements Structure.ByReference { }
class IcmpEchoReply extends AutoOrderedStructure { public IpAddrByVal address; public int status; public int roundTripTime; public short dataSize; public short reserved; public Pointer data; public IpOptionInformationByVal options;
public IcmpEchoReply() { }
public IcmpEchoReply(Pointer p) { useMemory(p); read(); } }
class Icmp6EchoReply extends AutoOrderedStructure { public short port; public byte[] flowInfo = new byte[4]; public byte[] addressBytes = new byte[16]; public int scopeId; public int status; public int roundTripTime;
public Icmp6EchoReply() { }
public Icmp6EchoReply(Pointer p) { useMemory(p); read(); } }}
",66,0,37,37,1.091,-1
"public final class OctetConverter { private OctetConverter() {}
/** * Converts a set of IPv4 octets to a 32-bit word. * * @param octets A byte array containing the IPv4 octets. * @param offset The offset into the array where the octets start. * @return The 32-bit word representation of the IPv4 address. */ public static int octetsToInt(byte[] octets, int offset) { return (((octets[offset] & 0xff) << 24) | ((octets[offset + 1] & 0xff) << 16) | ((octets[offset + 2] & 0xff) << 8) | (octets[offset + 3] & 0xff)); }
/** * Same as <code>octetsToInt(octets, 0);</code> */ public static int octetsToInt(byte[] octets) { return octetsToInt(octets, 0); }
/** * Converts a set of octets to a 64-bit word. * * @param octets A byte array containing the octets. * @param offset The offset into the array where the octets start. * @return The 64-bit word representation of the octets. */ public static long octetsToLong(byte[] octets, int offset) { return (((octets[offset] & 0xffffL) << 56) | ((octets[offset + 1] & 0xffL) << 48) | ((octets[offset + 2] & 0xffL) << 40) | ((octets[offset + 3] & 0xffL) << 32) | ((octets[offset + 4] & 0xffL) << 24) | ((octets[offset + 5] & 0xffL) << 16) | ((octets[offset + 6] & 0xffL) << 8) | (octets[offset + 7] & 0xffL)); }
/** * Same as <code>octetsToLong(octets, 0);</code> */ public static long octetsToLong(byte[] octets) { return octetsToLong(octets, 0); }
/** * Converts a set of IPv4 octets to a string representation. * * @param buffer The StringBuffer to which to append the string. * @param octets A byte array containing the IPv4 octets. * @param offset The offset into the array where the octets start. */ public static void octetsToString(StringBuffer buffer, byte[] octets, int offset) { buffer.append(octets[offset++] & 0xff); buffer.append("".""); buffer.append(octets[offset++] & 0xff); buffer.append("".""); buffer.append(octets[offset++] & 0xff); buffer.append("".""); buffer.append(octets[offset++] & 0xff); }
/** * Same as <code>octetsToString(buffer, octets, 0);</code> */ public static void octetsToString(StringBuffer buffer, byte[] octets) { octetsToString(buffer, octets, 0); }
/** * Converts a 32-bit word representation of an IPv4 address to a * string representation. * * @param buffer The StringBuffer to which to append the string. * @param address The 32-bit word representation of the address. */ public static void intToString(StringBuffer buffer, int address) { buffer.append(0xff & (address >>> 24)); buffer.append("".""); buffer.append(0xff & (address >>> 16)); buffer.append("".""); buffer.append(0xff & (address >>> 8)); buffer.append("".""); buffer.append(0xff & address); }
/** * Converts a 32-bit word representation of an IPv4 address to a * byte array of octets. * * @param address The 32-bit word representation of the IPv4 address. * @param octets The byte array in which to store the IPv4 octets. * @param offset The offset into the array where the octets start. */ public static void intToOctets(int address, byte[] octets, int offset) { octets[offset] = (byte)(0xff & (address >>> 24)); octets[offset + 1] = (byte)(0xff & (address >>> 16)); octets[offset + 2] = (byte)(0xff & (address >>> 8)); octets[offset + 3] = (byte)(0xff & address); }
/** * Same as <code>intToOctets(address, octets, 0);</code> */ public static void intToOctets(int address, byte[] octets) { intToOctets(address, octets, 0); }
/** * Converts a 64-bit word to a byte array of octets. * * @param address The 64-bit word. * @param octets The byte array in which to store octets. * @param offset The offset into the array where the octets start. */ public static void longToOctets(long address, byte[] octets, int offset) { octets[offset] = (byte)(0xffL & (address >>> 56)); octets[offset + 1] = (byte)(0xffL & (address >>> 48)); octets[offset + 2] = (byte)(0xffL & (address >>> 40)); octets[offset + 3] = (byte)(0xffL & (address >>> 32)); octets[offset + 4] = (byte)(0xffL & (address >>> 24)); octets[offset + 5] = (byte)(0xffL & (address >>> 16)); octets[offset + 6] = (byte)(0xffL & (address >>> 8)); octets[offset + 7] = (byte)(0xffL & address); }

/** * Same as <code>longToOctets(address, octets, 0);</code> */ public static void longToOctets(long address, byte[] octets) { longToOctets(address, octets, 0); }}
",66,0,12,7,0,0.583
